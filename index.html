<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Robot Mouse Catcher</title>
  <meta name="theme-color" content="#0f1830">
  <link rel="manifest" href="manifest.webmanifest">
  <style>
    body { margin: 0; background: #1a1a2e; color: #fff; font-family: system-ui, sans-serif; overflow: hidden; touch-action: none; }
    canvas { display: block; margin: auto; background: #16213e; border-radius: 12px; box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
    #hud { position: absolute; top: 10px; left: 10px; font-weight: bold; font-size: 18px; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
    #installHint { position: absolute; right: 10px; top: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); padding: 6px 10px; border-radius: 10px; font-size: 12px; }
  </style>
</head>
<body>
  <canvas id="game" width="900" height="600"></canvas>
  <div id="hud">Score: <span id="score">0</span></div>
  <div id="installHint" hidden>Add to Home Screen via Share ▶︎ Add to Home Screen</div>
  <script>
    // Register service worker (works over HTTPS/GitHub Pages)
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./sw.js').catch(console.error);
    }
    // iOS add-to-home-screen hint
    const isIOS = /iphone|ipad|ipod/i.test(navigator.userAgent);
    const isStandalone = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone;
    if (isIOS && !isStandalone) document.getElementById('installHint').hidden = false;

    // === GAME ===
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hudScore = document.getElementById('score');
    const DPR = Math.min(window.devicePixelRatio || 1, 2);
    function fit() {
      const cssW = Math.min(window.innerWidth, 900);
      const cssH = Math.min(window.innerHeight * 0.72, 600);
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      canvas.width = Math.round(cssW * DPR);
      canvas.height = Math.round(cssH * DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }
    fit();
    window.addEventListener('resize', fit);
    window.addEventListener('orientationchange', ()=>setTimeout(fit, 200));

    function W() { return canvas.width / DPR; }
    function H() { return canvas.height / DPR; }

    const robot = { x: W()/2, y: H() - 80, armLength: 140, armAngle: -Math.PI/2, grabbing: false };
    let mice = []; let spawnRate = 2; let lastSpawn = 0; let mouseSpeed = 100; let score = 0;

    function spawnMouse(){
      const side = Math.random() < 0.5 ? -20 : W() + 20;
      mice.push({ x: side, y: H() - 150 - Math.random()*Math.min(280, H()*0.5), size: 14, speed: mouseSpeed * (side < 0 ? 1 : -1) });
    }

    // Input
    canvas.addEventListener('pointerdown', () => { robot.grabbing = true; });
    canvas.addEventListener('pointerup', () => { robot.grabbing = false; });
    canvas.addEventListener('pointercancel', () => { robot.grabbing = false; });
    canvas.addEventListener('pointermove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left);
      const y = (e.clientY - rect.top);
      robot.armAngle = Math.atan2(y - robot.y, x - robot.x);
    });

    function update(dt){
      // spawn
      lastSpawn += dt;
      if (lastSpawn >= spawnRate){
        spawnMouse(); lastSpawn = 0; spawnRate = Math.max(0.6, spawnRate * 0.97); mouseSpeed *= 1.02;
      }
      // move mice
      for (const m of mice){ m.x += m.speed * dt; }
      mice = mice.filter(m => m.x > -60 && m.x < W()+60);

      // grab
      if (robot.grabbing){
        const tipX = robot.x + Math.cos(robot.armAngle) * robot.armLength;
        const tipY = robot.y + Math.sin(robot.armAngle) * robot.armLength;
        for (let i=mice.length-1; i>=0; i--){
          const m = mice[i], dx = tipX - m.x, dy = tipY - m.y;
          if (dx*dx + dy*dy < (m.size + 12)**2){ mice.splice(i,1); score++; hudScore.textContent = score; }
        }
      }
    }

    function draw(){
      ctx.clearRect(0,0,W(),H());
      // robot
      ctx.fillStyle = '#4ecca3';
      ctx.fillRect(robot.x-25, robot.y, 50, 60);
      // arm
      ctx.strokeStyle = '#f5a623';
      ctx.lineWidth = 12;
      ctx.beginPath();
      ctx.moveTo(robot.x, robot.y);
      ctx.lineTo(robot.x + Math.cos(robot.armAngle)*robot.armLength, robot.y + Math.sin(robot.armAngle)*robot.armLength);
      ctx.stroke();
      // tip
      ctx.fillStyle = robot.grabbing ? '#ff4757' : '#f5a623';
      ctx.beginPath();
      ctx.arc(robot.x + Math.cos(robot.armAngle)*robot.armLength, robot.y + Math.sin(robot.armAngle)*robot.armLength, 14, 0, Math.PI*2);
      ctx.fill();
      // mice
      for (const m of mice){
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(m.x, m.y, m.size, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#aaa';
        ctx.fillRect(m.x-10, m.y-3, 20, 3);
      }
    }

    let last = performance.now();
    function loop(){
      const now = performance.now();
      const dt = Math.min(0.033, (now - last)/1000);
      last = now;
      update(dt); draw();
      requestAnimationFrame(loop);
    }
    loop();
  </script>
</body>
</html>
